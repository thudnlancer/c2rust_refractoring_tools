/* This file is part of GNU cflow
   Copyright (C) 1997, 2005, 2007, 2010 Sergey Poznyakoff
 
   GNU cflow is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.
 
   GNU cflow is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public
   License along with GNU cflow; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301 USA */

use std::fmt::Write;
use std::io::{self, Write as IoWrite};

struct Symbol {
    name: String,
    arity: i32,
    decl: Option<String>,
    source: Option<String>,
    def_line: u32,
    active: u32,
    recursive: bool,
    callee: Option<Box<Symbol>>,
    caller: Option<Box<Symbol>>,
    expand_line: Option<u32>,
}

struct OutputSymbol {
    level: u32,
    last: bool,
    sym: Box<Symbol>,
    direct: bool,
}

enum CflowOutputCommand {
    Begin,
    Init,
    End,
    Separator,
    Newline,
    Text(String),
    Symbol(OutputSymbol),
}

static mut OUT_FILE: Option<Box<dyn IoWrite>> = None;
static mut PRINT_AS_TREE: bool = false;
static mut BRIEF_LISTING: bool = false;
static mut EMACS_OPTION: bool = false;
static PACKAGE_STRING: &str = "GNU cflow";

fn print_function_name(sym: &Symbol, has_subtree: bool) -> io::Result<()> {
    let outfile = unsafe { OUT_FILE.as_mut().unwrap() };
    write!(outfile, "{}", sym.name)?;
    
    if sym.arity >= 0 {
        write!(outfile, "()")?;
    }
    
    if let Some(decl) = &sym.decl {
        write!(outfile, " <{} at {}:{}>", decl, sym.source.as_ref().unwrap(), sym.def_line)?;
    }
    
    if sym.active > 0 {
        write!(outfile, " (recursive: see {})", sym.active - 1)?;
        return Ok(());
    }
    
    if sym.recursive {
        write!(outfile, " (R)")?;
    }
    
    if unsafe { !PRINT_AS_TREE } && has_subtree {
        write!(outfile, ":")?;
    }
    
    Ok(())
}

fn print_level(level: u32, last: bool) -> io::Result<()> {
    let outfile = unsafe { OUT_FILE.as_mut().unwrap() };
    for _ in 0..level {
        write!(outfile, "    ")?;
    }
    if last {
        write!(outfile, "`-- ")?;
    } else {
        write!(outfile, "|-- ")?;
    }
    Ok(())
}

fn print_symbol(outfile: &mut dyn IoWrite, line: u32, s: &OutputSymbol) -> io::Result<bool> {
    let has_subtree = if s.direct {
        s.sym.callee.is_some()
    } else {
        s.sym.caller.is_some()
    };
    
    print_level(s.level, s.last)?;
    print_function_name(&s.sym, has_subtree)?;
    
    if unsafe { BRIEF_LISTING } {
        if let Some(expand_line) = s.sym.expand_line {
            write!(outfile, " [see {}]", expand_line)?;
            return Ok(true);
        } else if s.sym.callee.is_some() {
            // In Rust we can't modify sym directly as it's borrowed
            // This would require different architecture with interior mutability
            // For now we'll skip this side effect
        }
    }
    Ok(false)
}

fn gnu_output_handler(
    cmd: CflowOutputCommand,
    outfile: &mut dyn IoWrite,
    line: u32,
) -> io::Result<bool> {
    match cmd {
        CflowOutputCommand::Begin => {
            if unsafe { EMACS_OPTION } {
                writeln!(outfile, ";; This file is generated by {}. -*- cflow -*-", PACKAGE_STRING)?;
            }
        }
        CflowOutputCommand::Newline => {
            writeln!(outfile)?;
        }
        CflowOutputCommand::Text(text) => {
            write!(outfile, "{}", text)?;
        }
        CflowOutputCommand::Symbol(sym) => {
            return print_symbol(outfile, line, &sym);
        }
        _ => {}
    }
    Ok(false)
}