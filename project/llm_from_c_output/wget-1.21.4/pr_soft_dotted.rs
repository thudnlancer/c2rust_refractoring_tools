/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
/* Properties of Unicode characters.  */
/* Generated automatically by gen-uni-tables.c for Unicode 15.0.0.  */

/* Copyright (C) 2000-2022 Free Software Foundation, Inc.

   This file is free software.
   It is dual-licensed under "the GNU LGPLv3+ or the GNU GPLv2+".
   You can redistribute it and/or modify it under either
     - the terms of the GNU Lesser General Public License as published
       by the Free Software Foundation, either version 3, or (at your
       option) any later version, or
     - the terms of the GNU General Public License as published by the
       Free Software Foundation; either version 2, or (at your option)
       any later version, or
     - the same dual license "the GNU LGPLv3+ or the GNU GPLv2+".

   This file is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License and the GNU General Public License
   for more details.

   You should have received a copy of the GNU Lesser General Public
   License and of the GNU General Public License along with this
   program.  If not, see <https://www.gnu.org/licenses/>.  */

const HEADER_0: usize = 16;
const HEADER_2: usize = 9;
const HEADER_3: usize = 127;
const HEADER_4: usize = 15;

struct UnicodePropertyTable {
    header: [i32; 1],
    level1: [i32; 2],
    level2: [i16; 256],
    level3: [u32; 176],
}

static U_PROPERTY_SOFT_DOTTED: UnicodePropertyTable = UnicodePropertyTable {
    header: [2],
    level1: [
        3 * std::mem::size_of::<i32>() as i32 / std::mem::size_of::<i16>() as i32 + 0,
        3 * std::mem::size_of::<i32>() as i32 / std::mem::size_of::<i16>() as i32 + 128,
    ],
    level2: [
        3 + 256 * std::mem::size_of::<i16>() as i32 / std::mem::size_of::<i32>() as i32 + 0,
        3 + 256 * std::mem::size_of::<i16>() as i32 / std::mem::size_of::<i32>() as i32 + 16,
        3 + 256 * std::mem::size_of::<i16>() as i32 / std::mem::size_of::<i32>() as i32 + 32,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        3 + 256 * std::mem::size_of::<i16>() as i32 / std::mem::size_of::<i32>() as i32 + 48,
        3 + 256 * std::mem::size_of::<i16>() as i32 / std::mem::size_of::<i32>() as i32 + 64,
        3 + 256 * std::mem::size_of::<i16>() as i32 / std::mem::size_of::<i32>() as i32 + 80,
        -1,
        -1,
        -1,
        -1,
        -1,
        3 + 256 * std::mem::size_of::<i16>() as i32 / std::mem::size_of::<i32>() as i32 + 96,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        3 + 256 * std::mem::size_of::<i16>() as i32 / std::mem::size_of::<i32>() as i32 + 112,
        3 + 256 * std::mem::size_of::<i16>() as i32 / std::mem::size_of::<i32>() as i32 + 128,
        -1,
        -1,
        -1,
        3 + 256 * std::mem::size_of::<i16>() as i32 / std::mem::size_of::<i32>() as i32 + 144,
        3 + 256 * std::mem::size_of::<i16>() as i32 / std::mem::size_of::<i32>() as i32 + 160,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
    ],
    level3: [
        0x00000000, 0x00000000, 0x00000000, 0x00000600,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x00000000, 0x00008000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000200, 0x00000100,
        0x20000000, 0x00040000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00080000,
        0x00000000, 0x00000000, 0x01400000, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00000004,
        0x00400000, 0x00000110, 0x00000000, 0x00000000,
        0x00000000, 0x00002000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000800, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00020000,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000300, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x10000000,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x00000000, 0x0000000C, 0x00C00000, 0x00000000,
        0x00000C00, 0xC0000000, 0x00000000, 0x000C0000,
        0x00000000, 0x000000C0, 0x0C000000, 0x00000000,
        0x0000C000, 0x00000000, 0x0000000C, 0x00C00000,
        0x00000000, 0x00000C00, 0xC0000000, 0x00000000,
        0x000C0000, 0x00000000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x04000000, 0x00000000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00003000, 0x00000100,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
    ],
};

pub fn uc_is_property_soft_dotted(uc: u32) -> bool {
    let index1 = uc >> 15;
    if index1 >= U_PROPERTY_SOFT_DOTTED.level1.len() as u32 {
        return false;
    }
    let index2 = (U_PROPERTY_SOFT_DOTTED.level1[index1 as usize] as u32 * 128) + ((uc >> 8) & 0x7F);
    if index2 >= U_PROPERTY_SOFT_DOTTED.level2.len() as u32 {
        return false;
    }
    let index3 = (U_PROPERTY_SOFT_DOTTED.level2[index2 as usize] as u32 * 16) + (uc & 0xFF);
    if index3 >= U_PROPERTY_SOFT_DOTTED.level3.len() as u32 {
        return false;
    }
    (U_PROPERTY_SOFT_DOTTED.level3[index3 as usize] & (1 << (uc & 0x1F))) != 0
}

pub struct UnicodeProperty {
    pub is_property: fn(u32) -> bool,
}

pub const UC_PROPERTY_SOFT_DOTTED: UnicodeProperty = UnicodeProperty {
    is_property: uc_is_property_soft_dotted,
};